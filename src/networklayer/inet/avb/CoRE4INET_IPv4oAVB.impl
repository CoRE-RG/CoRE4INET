//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
//

//==============================================================================

#include "CoRE4INET_IPv4oAVB.h"

//==============================================================================

#include "CoRE4INET_Defs.h"
#include "CoRE4INET_Buffer.h"
#include "CoRE4INET_SRPTable.h"
#include "AVBFrame_m.h"
#include "IPvXAddress.h"
#include "IPvXAddressResolver.h"
#include "UDPPacket.h"
#include "TCPSegment.h"
#include "cstringtokenizer.h"

#include <algorithm>

//==============================================================================

namespace CoRE4INET {

//==============================================================================

Define_Module(IPv4oAVB<IPv4>);

//==============================================================================

template<class base>
IPv4oAVB<base>::IPv4oAVB()
{
    // TODO Auto-generated constructor stub
    this->filterValid = false;
}

//==============================================================================

template<class base>
IPv4oAVB<base>::~IPv4oAVB()
{
    // TODO Auto-generated destructor stub
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::initialize(int stage)
{
    base::initialize(stage);
    if (!this->filterValid)
    {
        cXMLElement *filters = base::par("filters").xmlValue();
        configureFilters(filters);
        configureSubscriptions(filters);
        SRPTable *srpTable = check_and_cast<SRPTable *>(findModuleWhereverInNode("srpTable", this));
        registerSrpCallbacks(srpTable);
        base::scheduleAt(simTime(), new cMessage("blablub"));
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::registerSrpCallbacks(SRPTable *srpTable) {
    srpTable->subscribe("talkerRegistered", this);
    srpTable->subscribe("listenerRegistered", this);
    srpTable->subscribe("listenerUnregistered", this);
    srpTable->subscribe("listenerRegistrationTimeout", this);
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::sendPacketToNIC(cPacket *packet, const InterfaceEntry *ie)
{
    // Check for matching filters
    bool filterMatch = true;
    std::list<Filter*> matchingFilters;
    filterMatch = getMatchingFilters(packet, matchingFilters);

    // send to corresponding modules
    if(filterMatch) {
        sendPacketToBuffers(packet, ie, matchingFilters);
    } else {
        base::sendPacketToNIC(packet, ie);
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::handleMessage(cMessage* msg)
{
    if (msg->isSelfMessage() && (strcmp(msg->getName(), "blablub") == 0))
    {
        SRPTable *srpTable = check_and_cast<SRPTable *>(findModuleWhereverInNode("srpTable", this));
        registerTalker(this->m_filterList, srpTable);
        delete msg;
    }
    else if (dynamic_cast<AVBFrame*>(msg)) {
        AVBFrame* avbFrame = dynamic_cast<AVBFrame*>(msg);
        cPacket* ipPacket = avbFrame->decapsulate();

        Ieee802Ctrl *etherctrl = new Ieee802Ctrl();
        etherctrl->setSrc(avbFrame->getSrc());
        etherctrl->setDest(avbFrame->getDest());
        etherctrl->setEtherType(avbFrame->getEtherType());
        ipPacket->setControlInfo(etherctrl);

        ipPacket->setArrival(this, base::gate("AVBin")->getId());

        base::handleMessage(ipPacket);
    }
    else {
        base::handleMessage(msg);
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::receiveSignal(cComponent *src, simsignal_t id, cObject *obj)
{
    Enter_Method_Silent();
    if (id == base::registerSignal("talkerRegistered"))
    {
        SRPTable::TalkerEntry *tentry = check_and_cast<SRPTable::TalkerEntry*>(obj);

        if (std::find(m_subscribeList.begin(), m_subscribeList.end(), tentry->streamId) != m_subscribeList.end())
        {
            SRPTable *srpTable = check_and_cast<SRPTable *>(src);

            //TODO Minor: try to get VLAN
            srpTable->updateListenerWithStreamId(tentry->streamId, this, 0);
            // TODO: update timer???
        }
    }
    else if (id == base::registerSignal("listenerRegistrationTimeout"))
    {
        // TODO
//        SRPTable::ListenerEntry *lentry = check_and_cast<SRPTable::ListenerEntry*>(obj);
//        if (lentry->streamId == (unsigned int) par("streamID").longValue())
//        {
//            if (lentry->module == this)
//            {
//                getDisplayString().setTagArg("i2", 0, "status/hourglass");
//                simtime_t retryInterval = par("retryInterval").doubleValue();
//                if (retryInterval != 0)
//                {
//                    scheduleAt(simTime() + retryInterval, new cMessage("retrySubscription"));
//                }
//            }
//        }
    }
    else if (id == base::registerSignal("listenerRegistered"))
    {
        // TODO
    }
    else if (id == base::registerSignal("listenerUnregistered"))
    {
        //TODO
    }
    else
    {
        base::receiveSignal(src, id, obj);
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::addFilter(const Filter &filter)
{
    if (!filter.srcAddr.isUnspecified() && ((filter.srcAddr.isIPv6() && filter.srcPrefixLength > 128) ||
                                            (!filter.srcAddr.isIPv6() && filter.srcPrefixLength > 32)))
        throw cRuntimeError("srcPrefixLength is invalid");
    if (!filter.destAddr.isUnspecified() && ((filter.destAddr.isIPv6() && filter.destPrefixLength > 128) ||
                                             (!filter.destAddr.isIPv6() && filter.destPrefixLength > 32)))
        throw cRuntimeError("srcPrefixLength is invalid");
    if (filter.protocol != -1 && (filter.protocol < 0 || filter.protocol > 0xff))
        throw cRuntimeError("protocol is not a valid protocol number");
    if (filter.tos != -1 && (filter.tos < 0 || filter.tos > 0xff))
        throw cRuntimeError("tos is not valid");
    if (filter.tosMask < 0 || filter.tosMask > 0xff)
        throw cRuntimeError("tosMask is not valid");
    if (filter.srcPortMin != -1 && (filter.srcPortMin < 0 || filter.srcPortMin > 0xffff))
        throw cRuntimeError("srcPortMin is not a valid port number");
    if (filter.srcPortMax != -1 && (filter.srcPortMax < 0 || filter.srcPortMax > 0xffff))
        throw cRuntimeError("srcPortMax is not a valid port number");
    if (filter.srcPortMin != -1 && filter.srcPortMin > filter.srcPortMax)
        throw cRuntimeError("srcPortMin > srcPortMax");
    if (filter.destPortMin != -1 && (filter.destPortMin < 0 || filter.destPortMin > 0xffff))
        throw cRuntimeError("destPortMin is not a valid port number");
    if (filter.destPortMax != -1 && (filter.destPortMax < 0 || filter.destPortMax > 0xffff))
        throw cRuntimeError("destPortMax is not a valid port number");
    if (filter.destPortMin != -1 && filter.destPortMin > filter.destPortMax)
        throw cRuntimeError("destPortMin > destPortMax");

    m_filterList.push_back(filter);
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::configureFilters(cXMLElement *config)
{
    IPvXAddressResolver addressResolver;
    cXMLElementList filterElements = config->getChildrenByTagName("filter");
    for (int i = 0; i < (int)filterElements.size(); i++)
    {
        cXMLElement *filterElement = filterElements[i];
        try
        {
            const char *destType = getRequiredAttribute(filterElement, "destType");
            const char *destModule = getRequiredAttribute(filterElement, "destModule");
            const char *destMAC = getRequiredAttribute(filterElement, "destMAC");
            const char *alsoBE = getRequiredAttribute(filterElement, "alsoBE");
            const char *streamId = filterElement->getAttribute("streamId");
            const char *srcAddrAttr = filterElement->getAttribute("srcAddress");
            const char *srcPrefixLengthAttr = filterElement->getAttribute("srcPrefixLength");
            const char *destAddrAttr = filterElement->getAttribute("destAddress");
            const char *destPrefixLengthAttr = filterElement->getAttribute("destPrefixLength");
            const char *protocolAttr = filterElement->getAttribute("protocol");
            const char *tosAttr = filterElement->getAttribute("tos");
            const char *tosMaskAttr = filterElement->getAttribute("tosMask");
            const char *srcPortAttr = filterElement->getAttribute("srcPort");
            const char *srcPortMinAttr = filterElement->getAttribute("srcPortMin");
            const char *srcPortMaxAttr = filterElement->getAttribute("srcPortMax");
            const char *destPortAttr = filterElement->getAttribute("destPort");
            const char *destPortMinAttr = filterElement->getAttribute("destPortMin");
            const char *destPortMaxAttr = filterElement->getAttribute("destPortMax");

            Filter* filter = new Filter();

            if (!this->destTypeEnum) {
                this->destTypeEnum = cEnum::get("DestinationType");
            }

            if (destType)
                filter->destType = DestinationType(this->destTypeEnum->lookup(destType));
            switch (filter->destType) {
                case DestinationType_AVB:
                    {
                        cModule* module = simulation.getModuleByPath(destModule);
                        if (!module) {
                           module = findModuleWhereverInNode(destModule, this);
                        }
                        if (!module) {
                           throw cRuntimeError("destModule \"%s\" could not be resolved!", destModule);
                        }
                        if (AVBIncoming *avbCtc = dynamic_cast<AVBIncoming*>(module)) {
                           filter->avbDestInfo.destModule = avbCtc;
                        } else {
                            throw cRuntimeError("destModule: %s is not a AVBIncoming!", destModule);
                        }
                        if (destMAC)
                            filter->avbDestInfo.destMAC.setAddress(destMAC);
                        else
                             throw cRuntimeError("destMAC not specified!");
                        filter->avbDestInfo.streamId = parseIntAttribute(streamId, "streamId", false);
                    }
                    break;
                default :
                    throw cRuntimeError("Invalid destType: %s", destType);
                    break;
            }
            if (alsoBE)
                filter->alsoBE = parseIntAttribute(alsoBE, "alsoBE", false) != 0;
            if (srcAddrAttr)
                filter->srcAddr = addressResolver.resolve(srcAddrAttr);
            if (srcPrefixLengthAttr)
                filter->srcPrefixLength = parseIntAttribute(srcPrefixLengthAttr, "srcPrefixLength");
            else if (srcAddrAttr)
                filter->srcPrefixLength = filter->srcAddr.isIPv6() ? 128 : 32;
            if (destAddrAttr)
                filter->destAddr = addressResolver.resolve(destAddrAttr);
            if (destPrefixLengthAttr)
                filter->destPrefixLength = parseIntAttribute(destPrefixLengthAttr, "destPrefixLength");
            else if (destAddrAttr)
                filter->destPrefixLength = filter->destAddr.isIPv6() ? 128 : 32;
            if (protocolAttr)
                filter->protocol = parseProtocol(protocolAttr, "protocol");
            if (tosAttr)
                filter->tos = parseIntAttribute(tosAttr, "tos");
            if (tosMaskAttr)
                filter->tosMask = parseIntAttribute(tosAttr, "tosMask");
            if (srcPortAttr)
                filter->srcPortMin = filter->srcPortMax = parseIntAttribute(srcPortAttr, "srcPort");
            if (srcPortMinAttr)
                filter->srcPortMin = parseIntAttribute(srcPortMinAttr, "srcPortMin");
            if (srcPortMaxAttr)
                filter->srcPortMax = parseIntAttribute(srcPortMaxAttr, "srcPortMax");
            if (destPortAttr)
                filter->destPortMin = filter->destPortMax = parseIntAttribute(destPortAttr, "destPort");
            if (destPortMinAttr)
                filter->destPortMin = parseIntAttribute(destPortMinAttr, "destPortMin");
            if (destPortMaxAttr)
                filter->destPortMax = parseIntAttribute(destPortMaxAttr, "destPortMax");

            addFilter(*filter);
        }
        catch (std::exception& e)
        {
            throw cRuntimeError("Error in XML <filter> element at %s: %s", filterElement->getSourceLocation(), e.what());
        }
    }

    this->filterValid = true;
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::configureSubscriptions(cXMLElement *config)
{
    cXMLElementList filterElements = config->getChildrenByTagName("subscribe");
    for (int i = 0; i < (int)filterElements.size(); i++)
    {
        cXMLElement *filterElement = filterElements[i];
        try
        {
            const char *streamId = getRequiredAttribute(filterElement, "streamId");

            if (streamId) {
                int id = parseIntAttribute(streamId, "streamId");
                m_subscribeList.push_back(id);
            }
        }
        catch (std::exception& e)
        {
            throw cRuntimeError("Error in XML <subscribe> element at %s: %s", filterElement->getSourceLocation(), e.what());
        }
    }

    this->filterValid = true;
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::registerTalker(const std::list<IPv4oAVB<base>::Filter> filters, SRPTable *srpTable)
{
    typename std::list<IPv4oAVB<base>::Filter>::const_iterator filter = filters.begin();
    for ( ; filter != filters.end(); ++filter) {
        if (filter->destType == DestinationType_AVB) {
            registerTalker(&(*filter), srpTable);
        }
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::registerTalker(const Filter* filter, SRPTable *srpTable)
{
    if (srpTable)
    {
        EV << "Register Talker in node" << std::endl;
        // TODO: Class, framesize, intervallframes, vid(?) im filter hinzufügen
        srpTable->updateTalkerWithStreamId(filter->avbDestInfo.streamId, this, filter->avbDestInfo.destMAC, SR_CLASS_A, 300, 1);
        base::getDisplayString().setTagArg("i2", 0, "status/hourglass");
    }
    else
    {
        throw cRuntimeError("srpTable module required for stream reservation");
    }
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::sendPacketToBuffers(cPacket *packet, const InterfaceEntry *ie, std::list<Filter*> &filters)
{
    if (packet->getByteLength() > MAX_ETHERNET_DATA_BYTES)
        base::error("packet from higher layer (%d bytes) exceeds maximum Ethernet payload length (%d)", (int)packet->getByteLength(), MAX_ETHERNET_DATA_BYTES);

    typename std::list<Filter*>::iterator filter = filters.begin();
    for ( ; filter != filters.end(); ++filter) {
        switch ((*filter)->destType) {
        case DestinationType_AVB:
            {
                sendAVBFrame(packet->dup(), ie, (*filter));
                break;
            }
        default:
            {
                break;
            }
        }
        if ((*filter)->alsoBE) {
            base::sendPacketToNIC(packet->dup(), ie);
        }
    }

    delete packet;
}

//==============================================================================

template<class base>
void IPv4oAVB<base>::sendAVBFrame(cPacket* packet, const InterfaceEntry* ie, const Filter* filter)
{
    std::stringstream name;
    name << "Stream " << filter->avbDestInfo.streamId;
    AVBFrame *outFrame = new AVBFrame(name.str().c_str());
    outFrame->setStreamID(filter->avbDestInfo.streamId);
    outFrame->setDest(filter->avbDestInfo.destMAC);
    outFrame->setEtherType(ETHERTYPE_IPv4);

    outFrame->encapsulate(packet);

    if (outFrame->getByteLength() < MIN_ETHERNET_FRAME_BYTES)
    {
        outFrame->setByteLength(MIN_ETHERNET_FRAME_BYTES);
    }
    base::sendDirect(outFrame, filter->avbDestInfo.destModule->gate("in"));

}

//==============================================================================

template<class base>
const char *IPv4oAVB<base>::getRequiredAttribute(cXMLElement *element, const char *attrName)
{
    const char *attrValue = element->getAttribute(attrName);
    if (!attrValue)
        throw cRuntimeError("missing attribute '%s' from <%s> element", attrName, element->getTagName());
    return attrValue;
}

//==============================================================================

template<class base>
int IPv4oAVB<base>::parseIntAttribute(const char *attrValue, const char *attrName, bool isOptional)
{
    if (isEmpty(attrValue))
    {
        if (isOptional)
            return -1;
        else
            throw cRuntimeError("missing %s attribute", attrName);
    }

    unsigned long num;
    char *endp;
    if (*attrValue == '0' && *(attrValue+1) == 'b') // 0b prefix for binary
        num = strtoul(attrValue+2, &endp, 2);
    else
        num = strtoul(attrValue, &endp, 0); // will handle hex/octal/decimal

    if (*endp != '\0')
        throw cRuntimeError("malformed %s attribute: %s", attrName, attrValue);

    if (num > INT_MAX)
        throw cRuntimeError("attribute %s is too large: %s", attrName, attrValue);

    return (int)num;
}

//==============================================================================

template<class base>
int IPv4oAVB<base>::parseProtocol(const char *attrValue, const char *attrName)
{
    if (isEmpty(attrValue))
        return -1;
    if (isdigit(*attrValue))
        return parseIntAttribute(attrValue, attrName);
    if (!m_protocolEnum)
        m_protocolEnum = cEnum::get("IPProtocolId");
    char name[20];
    strcpy(name, "IP_PROT_");
    char *dest;
    for (dest = name+8; *attrValue; ++dest, ++attrValue)
        *dest = toupper(*attrValue);
    *dest = '\0';

    return m_protocolEnum->lookup(name);
}

//==============================================================================

template<class base>
bool IPv4oAVB<base>::getMatchingFilters(cPacket *packet, std::list<Filter*> &filters)
{
    bool foundMatch = false;
    typename std::list<Filter>::iterator filter = m_filterList.begin();
    while(filter != m_filterList.end()) {
        if (filter->matches(packet)) {
            filters.push_back(&(*filter));
            foundMatch = true;
        }
        ++filter;
    }
    return foundMatch;
}

//==============================================================================

template<class base>
bool IPv4oAVB<base>::Filter::matches(cPacket *packet)
{
    IPv4Datagram *datagram = dynamic_cast<IPv4Datagram*>(packet);
    if (!datagram)
        return false;

    if (srcPrefixLength > 0 && (srcAddr.isIPv6() || !datagram->getSrcAddress().prefixMatches(srcAddr.get4(), srcPrefixLength)))
        return false;
    if (destPrefixLength > 0 && (destAddr.isIPv6() || !datagram->getDestAddress().prefixMatches(destAddr.get4(), destPrefixLength)))
        return false;
    if (protocol >= 0 && datagram->getTransportProtocol() != protocol)
        return false;
    if (tosMask != 0 && (tos & tosMask) != (datagram->getTypeOfService() & tosMask))
        return false;
    if (srcPortMin >= 0 || destPortMin >= 0)
    {
        int srcPort = -1, destPort = -1;
        cPacket *encPacket = packet->getEncapsulatedPacket();
        UDPPacket *udpPacket = dynamic_cast<UDPPacket*>(encPacket);
        if (udpPacket)
        {
            srcPort = udpPacket->getSourcePort();
            destPort = udpPacket->getDestinationPort();
        }
        TCPSegment *tcpSegment = dynamic_cast<TCPSegment*>(encPacket);
        if (tcpSegment)
        {
            srcPort = tcpSegment->getSrcPort();
            destPort = tcpSegment->getDestPort();
        }

        if (srcPortMin >= 0 && (srcPort < srcPortMin || srcPort > srcPortMax))
            return false;
        if (destPortMin >= 0 && (destPort < destPortMin || destPort > destPortMax))
            return false;
    }
    return true;
}

//==============================================================================

} /* namespace CoRE4INET */
